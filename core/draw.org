#+TITLE: Draw
Some basic drawing primitives, using =gfxbuf=.

WIP.

#+NAME: draw.c
#+BEGIN_SRC c :tangle core/draw.c
#include "mathc/mathc.h"
#include "gfxbuf.h"
#include "draw.h"
<<funcs>>
#+END_SRC

#+NAME: draw.h
#+BEGIN_SRC c :tangle core/draw.h
#ifndef MNO_DRAW_H
#define MNO_DRAW_H
<<funcdefs>>
#endif
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gfxdrw_rect_filled(gfxbuf *buf,
                        int x, int y,
                        int w, int h,
                        int clr);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void gfxdrw_rect_filled(gfxbuf *buf,
                        int xpos, int ypos,
                        int w, int h,
                        int clr)
{
    gfxbuf_pixel pix;
    int xe, ye;
    int x, y;

    xe = xpos + w;
    ye = ypos + h;

    pix = gfxbuf_clrget(buf, clr);

    for (y = ypos; y < ye; y++) {
        for (x = xpos; x < xe; x++) {
            gfxbuf_set(buf, x, y, pix);
        }
    }

}
#+END_SRC

#+NAME: funcdefs
#+BEGIN_SRC c
void gfxdrw_circ_filled(gfxbuf *gfx,
                        double cx, double cy,
                        double r,
                        int clrpos);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
static float sdfcirc(struct vec2 p, float r)
{
    return svec2_length(p) - r;
}

struct vec2 normalize(struct vec2 pos, struct vec2 res)
{
    struct vec2 p;
    p = svec2_multiply_f(pos, 2.0);
    p = svec2_subtract(p, res);
    p = svec2_divide_f(p, res.y);
    return p;
}

static float smoothstep(float e0, float e1, float x)
{
    float t;
    t = clampf((x - e0) / (e1 - e0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

static float sign(float x)
{
    if (x < 0) return -1;
    else if (x > 0) return 1;
    return 0;
}

static void circ(gfxbuf_state *st)
{
    float d;
    struct vec3 col;
    float alpha;
    struct vec2 p;
    struct vec2 res;
    gfxbuf_pixel *pix;
    struct vec3 bg;


    res = svec2(st->info->rw, st->info->rh);

    pix = st->info->ud;

    p = normalize(svec2(st->x, st->y), res);
    d = -sdfcirc(p, 0.9);

    alpha = 0;
    alpha = sign(d) > 0;

    alpha += smoothstep(3.0 / st->info->rw, 0.0, fabs(d));
    alpha = clampf(alpha, 0, 1);

    bg.x = st->out->r;
    bg.y = st->out->g;
    bg.z = st->out->b;

    bg = svec3(st->out->r, st->out->g, st->out->b);
    col = svec3(pix->r, pix->g, pix->b);
    col = svec3_lerp(bg, col, alpha);

    st->out->r = col.x;
    st->out->g = col.y;
    st->out->b = col.z;
}

void gfxdrw_circ_filled(gfxbuf *gfx,
                        double cx, double cy,
                        double r,
                        int clrpos)
{
    gfxbuf_pixel clr;
    int x, y;
    int w, h;

    w = 2 * r;
    h = w;

    x = cx - r;
    y = cy - r;

    clr = gfxbuf_clrget(gfx, clrpos);

    gfxbuf_draw(gfx, x, y, w, h, circ, &clr);
}
#+END_SRC
