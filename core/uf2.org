#+TITLE: UF2 font rendering
UF2 is the uxn proportional width font format.
* Tangled Files
struct uf2_glyph {
    struct uf2_block tl, bl, tr, br;
};
#+NAME: core/uf2.c
#+BEGIN_SRC c :tangle core/uf2.c
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "btprnt/btprnt.h"
#include "sndkit/lil/lil.h"
#include "sndkit/graforge/graforge.h"
#include "sndkit/core.h"
#include "sndkit/nodes/sklil.h"
#include "lua/lua.h"
#include "lua/lauxlib.h"
#include "lua/lualib.h"
#define MNOLTH_UF2_PRIV
#include "uf2.h"

int lil_btprnt_region(lil_t lil, sk_core *core, btprnt_region **reg);
<<funcs>>
#+END_SRC

#+NAME: core/uf2.h
#+BEGIN_SRC c :tangle core/uf2.h
#ifndef MNOLTH_UF2_H
#define MNOLTH_UF2_H
<<typedefs>>
#ifdef MNOLTH_UF2_PRIV
<<structs>>
#endif
<<funcdefs>>
#endif
#+END_SRC
* Core Structs
** Block
#+NAME: structs
#+BEGIN_SRC c
struct uf2_block {
    uint8_t data[8];
};
#+END_SRC
** Glyph
#+NAME: structs
#+BEGIN_SRC c
struct uf2_glyph {
    struct uf2_block tl, bl, tr, br;
};
#+END_SRC
** Font
#+NAME: structs
#+BEGIN_SRC c
struct uf2_font {
    uint8_t widths[256];
    struct uf2_glyph glyphs[256];
};
#+END_SRC
* uf2 struct size
Should be 8448 (256 header size + 8192 (256 * 32)
bitmap data).
#+NAME: funcdefs
#+BEGIN_SRC c
size_t uf2_size(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
size_t uf2_size(void)
{
    return sizeof(struct uf2_font);
}
#+END_SRC
* Load A Font
#+NAME: funcdefs
#+BEGIN_SRC c
int uf2_load(struct uf2_font *fnt, const char *filename);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
int uf2_load(struct uf2_font *fnt, const char *filename)
{
    FILE *fp;
    fp = fopen(filename, "rb");
    if (fp == NULL) return 1;
    fread(fnt, 1, sizeof(struct uf2_font), fp);
    fclose(fp);
    return 0;
}
#+END_SRC
* Rendering
#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_uf2_draw_textline(btprnt_region *r,
                             struct uf2_font *fnt,
                             int xoff, int yoff,
                             const char *line);
int btprnt_uf2_draw_bytes(btprnt_region *r,
                          struct uf2_font *fnt,
                          int xoff, int yoff,
                          const unsigned char *buf,
                          size_t len);
#+END_SRC
** Textline
#+NAME: funcs
#+BEGIN_SRC c
int btprnt_uf2_draw_textline(btprnt_region *r,
                             struct uf2_font *fnt,
                             int xoff, int yoff,
                             const char *line)
{
    return btprnt_uf2_draw_bytes(r,
                                 fnt,
                                 xoff, yoff,
                                 (const unsigned char *)line,
                                 strlen(line));
}
#+END_SRC
** Buffer
#+NAME: funcs
#+BEGIN_SRC c
<<write_block>>
int btprnt_uf2_draw_bytes(btprnt_region *r,
                          struct uf2_font *fnt,
                          int xoff, int yoff,
                          const unsigned char *buf,
                          size_t len)
{
    size_t i;

    for (i = 0; i < len; i++) {
        struct uf2_glyph *g;
        uint8_t c;
        c = buf[i];
        g = &fnt->glyphs[c];
        write_block(r, &g->tl, xoff + 0, yoff);
        write_block(r, &g->bl, xoff + 0, yoff + 8);
        write_block(r, &g->tr, xoff + 8, yoff);
        write_block(r, &g->br, xoff + 8, yoff + 8);
        xoff += fnt->widths[c];
    }

    return xoff;
}
#+END_SRC
** Write a Single Block
Fonts in UF2 are split up into 4 8x8 pixel blocks.
#+NAME: write_block
#+BEGIN_SRC c
static void write_block(btprnt_region *r,
                        struct uf2_block *blk,
                        int xoff, int yoff)
{
    int x, y;
    uint8_t *dat;

    dat = blk->data;
    for (y = 0; y < 8; y++) {
        for (x = 0; x < 8; x++) {
            int row;
            int qpos;
            qpos = y;
            row = dat[qpos];
            if (row & (1 << x)) {
                btprnt_region_draw(r, (7 - x) + xoff, y + yoff, 1);
            }

            /* only draw for on bits */
        }
    }

}
#+END_SRC
* Buffer
LIL doesn't have a great way of handling blocks memory,
which is needed for =btprnt_uf2_draw_bytes=. The idea
is to construct a pre-allocated chunk of memory that LIL
can read from. The idea is that LIL would run inside of
Lua, and Lua would be able to fill the chunk of memory
before making the call.
** Struct Declaration
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct mno_buffer mno_buffer;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC
struct mno_buffer {
    unsigned char *buf;
    size_t len;
    size_t cap;
};
#+END_SRC
** Creating a new buffer (bufnew via LIL)
The =bufnew= will create a new named buffer in sndkit
pre-allocated to user-defined max capacity (in bytes).

#+BEGIN_SRC lil
bufnew buf 256
#+END_SRC

#+NAME: entries
#+BEGIN_SRC c
lil_register(lil, "bufnew", l_bufnew);
#+END_SRC

#+NAME: loadfuncs
#+BEGIN_SRC c
static void delbuf(void *ptr)
{
    mno_buffer *buf;

    buf = ptr;

    free(buf->buf);
    free(buf);
    ptr = buf = NULL;
}

static lil_value_t l_bufnew(lil_t lil,
                            size_t argc,
                            lil_value_t *argv)
{
    int rc;
    const char *key;
    size_t cap;
    mno_buffer *buf;
    sk_core *core;

    SKLIL_ARITY_CHECK(lil, "bufnew", argc, 2);

    core = lil_get_data(lil);

    key = lil_to_string(argv[0]);
    cap = lil_to_integer(argv[1]);

    buf = malloc(sizeof(mno_buffer));
    buf->buf = calloc(1, cap);
    buf->cap = cap;
    buf->len = 0;

    rc = sk_core_append(core, key, strlen(key), buf, delbuf);

    SKLIL_ERROR_CHECK(lil, rc, "bufnew didn't work out.");

    return NULL;
}
#+END_SRC
** Appending Bytes
*** Appending Bytes in C
#+NAME: funcdefs
#+BEGIN_SRC c
int mno_buffer_appendbyte(mno_buffer *buf, unsigned char c);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
int mno_buffer_appendbyte(mno_buffer *buf, unsigned char c)
{
    if (buf->len >= buf->cap) return 0;
    buf->buf[buf->len] = c;
    buf->len++;
    return 1;
}
#+END_SRC
*** Appending Bytes in Lua
#+NAME: lua_funcs
#+BEGIN_SRC c
static int buffer_append(lua_State *L)
{
    mno_buffer *buf;
    buf = lua_touserdata(L, 1);

    if (lua_istable(L, 2)) {
        printf("table\n");
    }

    lua_pushnil(L);

    while (lua_next(L, 2)) {
        unsigned char byte;
        byte = (unsigned char)lua_tointeger(L, -1) & 0xFF;
        mno_buffer_appendbyte(buf, byte);
        lua_pop(L, 1);
    }

    return 0;
}
#+END_SRC
** Clearing the Buffer
This will reset the buffer to zero
*** Clearing the Buffer in C
The =mno_buffer_clear= function will reset the buffer
position to be zero, but it will *not* zero out the
contents.

#+NAME: funcdefs
#+BEGIN_SRC c
void mno_buffer_clear(mno_buffer *buf);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
void mno_buffer_clear(mno_buffer *buf)
{
    buf->len = 0;
}
#+END_SRC
*** Clearing the Buffer in Lua
#+NAME: lua_funcs
#+BEGIN_SRC c
static int buffer_clear(lua_State *L)
{
    mno_buffer *buf;
    buf = lua_touserdata(L, 1);
    mno_buffer_clear(buf);
    return 0;
}
#+END_SRC
** Lua Loader
(Note that this isn't forward-declared, this is done to
avoid needing to include lua headers everywhere uf2 is
used.)
#+NAME: funcs
#+BEGIN_SRC c
<<lua_funcs>>
static const luaL_Reg buffer_lib[] = {
    {"append", buffer_append},
    {"clear", buffer_clear},
    {NULL, NULL}
};

int luaopen_mnobuf(lua_State *L)
{
    luaL_newlib(L, buffer_lib);
    return 1;
}
#+END_SRC
** Reading the Buffer
For now, just gets for buffer and size are all that
is needed.

#+NAME: funcdefs
#+BEGIN_SRC c
unsigned char * mno_buffer_data(mno_buffer *buf);
size_t mno_buffer_length(mno_buffer *buf);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
unsigned char * mno_buffer_data(mno_buffer *buf)
{
    return buf->buf;
}

size_t mno_buffer_length(mno_buffer *buf)
{
    return buf->len;
}
#+END_SRC
* TODO LIL
** TODO Loader
#+NAME: funcdefs
#+BEGIN_SRC c
void lil_load_uf2(lil_t lil);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<loadfuncs>>
void lil_load_uf2(lil_t lil)
{
    <<entries>>
}
#+END_SRC
** uf2load
Loads a uf2 font into memory into a sndkit dictionary entry.

Usage: uf2load key filename

#+NAME: entries
#+BEGIN_SRC c
lil_register(lil, "uf2load", l_uf2load);
#+END_SRC

#+NAME: loadfuncs
#+BEGIN_SRC c
static void deluf2(void *ptr)
{
    struct uf2_font *fnt;

    fnt = ptr;

    free(fnt);
    ptr = fnt = NULL;
}

static lil_value_t l_uf2load(lil_t lil,
                             size_t argc,
                             lil_value_t *argv)
{
    int rc;
    const char *key;
    const char *filename;
    struct uf2_font *fnt;
    sk_core *core;

    SKLIL_ARITY_CHECK(lil, "uf2load", argc, 2);

    core = lil_get_data(lil);

    key = lil_to_string(argv[0]);
    filename = lil_to_string(argv[1]);

    fnt = malloc(uf2_size());

    /* TODO: handle what happens if load files */
    uf2_load(fnt, filename);

    rc = sk_core_append(core, key, strlen(key),
                        fnt, deluf2);

    SKLIL_ERROR_CHECK(lil, rc, "uf2load didn't work out.");

    return NULL;
}
#+END_SRC
** uf2txtln
Wrapper for =btprnt_uf2_draw_textline=.

Usage: uf2txtln region font x y text

#+NAME: entries
#+BEGIN_SRC c
lil_register(lil, "uf2txtln", l_uf2txtln);
#+END_SRC

#+NAME: loadfuncs
#+BEGIN_SRC c
/* TODO: move getuf2 to a better spot */
static int getuf2(lil_t lil, sk_core *core, struct uf2_font **fnt)
{

    void *ud;
    int rc;

    rc = sk_core_generic_pop(core, &ud);

    if (rc) {
        lil_set_error(lil, "Could not get uf2 font");
        return 1;
    }

    *fnt = (struct uf2_font *)ud;
    return 0;
}
static lil_value_t l_uf2txtln(lil_t lil,
                              size_t argc,
                              lil_value_t *argv)
{
    int x, y;
    int rc;
    sk_core *core;
    const char *str;
    btprnt_region *reg;
    struct uf2_font *fnt;

    SKLIL_ARITY_CHECK(lil, "uf2txtln", argc, 5);
    core = lil_get_data(lil);

    rc = getuf2(lil, core, &fnt);
    if (rc) return NULL;

    rc = lil_btprnt_region(lil, core, &reg);
    if (rc) return NULL;

    x = lil_to_integer(argv[2]);
    y = lil_to_integer(argv[3]);
    str = lil_to_string(argv[4]);

    btprnt_uf2_draw_textline(reg, fnt, x, y, str);

    if (rc) return NULL;

    return NULL;
}
#+END_SRC
** TODO uf2bytes
This is a wrapper for =btprnt_uf2_draw_bytes=.

Reads from a pre-allocated buffer (not yet invented yet).

Usage: uf2bytes region font x y buffer
