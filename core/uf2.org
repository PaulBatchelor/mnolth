#+TITLE: UF2 font rendering
UF2 is the uxn proportional width font format.
* Tangled Files
struct uf2_glyph {
    struct uf2_block tl, bl, tr, br;
};
#+NAME: core/uf2.c
#+BEGIN_SRC c :tangle core/uf2.c
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include "btprnt/btprnt.h"
#include "sndkit/lil/lil.h"
#include "sndkit/graforge/graforge.h"
#include "sndkit/core.h"
#include "sndkit/nodes/sklil.h"
#define MNOLTH_UF2_PRIV
#include "uf2.h"
<<funcs>>
#+END_SRC

#+NAME: core/uf2.h
#+BEGIN_SRC c :tangle core/uf2.h
#ifndef MNOLTH_UF2_H
#define MNOLTH_UF2_H
#ifdef MNOLTH_UF2_PRIV
<<structs>>
#endif
<<funcdefs>>
#endif
#+END_SRC
* Core Structs
** Block
#+NAME: structs
#+BEGIN_SRC c
struct uf2_block {
    uint8_t data[8];
};
#+END_SRC
** Glyph
#+NAME: structs
#+BEGIN_SRC c
struct uf2_glyph {
    struct uf2_block tl, bl, tr, br;
};
#+END_SRC
** Font
#+NAME: structs
#+BEGIN_SRC c
struct uf2_font {
    uint8_t widths[256];
    struct uf2_glyph glyphs[256];
};
#+END_SRC
* uf2 struct size
Should be 8448 (256 header size + 8192 (256 * 32)
bitmap data).
#+NAME: funcdefs
#+BEGIN_SRC c
size_t uf2_size(void);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
size_t uf2_size(void)
{
    return sizeof(struct uf2_font);
}
#+END_SRC
* Load A Font
#+NAME: funcdefs
#+BEGIN_SRC c
int uf2_load(struct uf2_font *fnt, const char *filename);
#+END_SRC
#+NAME: funcs
#+BEGIN_SRC c
int uf2_load(struct uf2_font *fnt, const char *filename)
{
    FILE *fp;
    fp = fopen(filename, "rb");
    if (fp == NULL) return 1;
    fread(fnt, 1, sizeof(struct uf2_font), fp);
    fclose(fp);
    return 0;
}
#+END_SRC
* Rendering
#+NAME: funcdefs
#+BEGIN_SRC c
int btprnt_uf2_draw_textline(btprnt_region *r,
                             struct uf2_font *fnt,
                             int xoff, int yoff,
                             const char *line);
int btprnt_uf2_draw_bytes(btprnt_region *r,
                          struct uf2_font *fnt,
                          int xoff, int yoff,
                          const unsigned char *buf,
                          size_t len);
#+END_SRC
** Textline
#+NAME: funcs
#+BEGIN_SRC c
int btprnt_uf2_draw_textline(btprnt_region *r,
                             struct uf2_font *fnt,
                             int xoff, int yoff,
                             const char *line)
{
    return btprnt_uf2_draw_bytes(r,
                                 fnt,
                                 xoff, yoff,
                                 (const unsigned char *)line,
                                 strlen(line));
}
#+END_SRC
** Buffer
#+NAME: funcs
#+BEGIN_SRC c
<<write_block>>
int btprnt_uf2_draw_bytes(btprnt_region *r,
                          struct uf2_font *fnt,
                          int xoff, int yoff,
                          const unsigned char *buf,
                          size_t len)
{
    size_t i;

    for (i = 0; i < len; i++) {
        struct uf2_glyph *g;
        uint8_t c;
        c = buf[i];
        g = &fnt->glyphs[c];
        write_block(r, &g->tl, xoff + 0, yoff);
        write_block(r, &g->bl, xoff + 0, yoff + 8);
        write_block(r, &g->tr, xoff + 8, yoff);
        write_block(r, &g->br, xoff + 8, yoff + 8);
        xoff += fnt->widths[c];
    }

    return xoff;
}
#+END_SRC
** Write a Single Block
Fonts in UF2 are split up into 4 8x8 pixel blocks.
#+NAME: write_block
#+BEGIN_SRC c
static void write_block(btprnt_region *r,
                        struct uf2_block *blk,
                        int xoff, int yoff)
{
    int x, y;
    uint8_t *dat;

    dat = blk->data;
    for (y = 0; y < 8; y++) {
        for (x = 0; x < 8; x++) {
            int row;
            int qpos;
            qpos = y;
            row = dat[qpos];
            if (row & (1 << x)) {
                btprnt_region_draw(r, (7 - x) + xoff, y + yoff, 1);
            }

            /* only draw for on bits */
        }
    }

}
#+END_SRC
* TODO Buffer
LIL doesn't have a great way of handling blocks memory,
which is needed for =btprnt_uf2_draw_bytes=. The idea
is to construct a pre-allocated chunk of memory that LIL
can read from. The idea is that LIL would run inside of
Lua, and Lua would be able to fill the chunk of memory
before making the call.
* TODO LIL
** TODO Loader
#+NAME: funcdefs
#+BEGIN_SRC c
void lil_load_uf2(lil_t lil);
#+END_SRC

#+NAME: funcs
#+BEGIN_SRC c
<<loadfuncs>>
void lil_load_uf2(lil_t lil)
{
    /* TODO: add entries */
    <<entries>>
}
#+END_SRC
** uf2load
Loads a uf2 font into memory into a sndkit dictionary entry.

Usage: uf2load key filename

#+NAME: entries
#+BEGIN_SRC c
lil_register(lil, "uf2load", l_uf2load);
#+END_SRC

#+NAME: loadfuncs
#+BEGIN_SRC c
static void deluf2(void *ptr)
{
    struct uf2_font *fnt;

    fnt = ptr;

    free(fnt);
    ptr = fnt = NULL;
}

static lil_value_t l_uf2load(lil_t lil,
                             size_t argc,
                             lil_value_t *argv)
{
    int rc;
    const char *key;
    const char *filename;
    struct uf2_font *fnt;
    sk_core *core;

    SKLIL_ARITY_CHECK(lil, "uf2load", argc, 2);

    core = lil_get_data(lil);

    key = lil_to_string(argv[0]);
    filename = lil_to_string(argv[1]);

    fnt = malloc(uf2_size());

    /* TODO: handle what happens if load files */
    uf2_load(fnt, filename);

    rc = sk_core_append(core, key, strlen(key),
                        fnt, deluf2);

    SKLIL_ERROR_CHECK(lil, rc, "uf2load didn't work out.");

    return NULL;
}
#+END_SRC
** TODO uf2txtln
Wrapper for =btprnt_uf2_draw_textline=.

Usage: uf2txtln region font x y text

#+NAME: entries
#+BEGIN_SRC c
lil_register(lil, "uf2txtln", l_uf2txtln);
#+END_SRC

#+NAME: loadfuncs
#+BEGIN_SRC c
static lil_value_t l_uf2txtln(lil_t lil,
                              size_t argc,
                              lil_value_t *argv)
{
    /* TODO implement */
    return NULL;
}
#+END_SRC
** TODO uf2bytes
This is a wrapper for =btprnt_uf2_draw_bytes=.

Reads from a pre-allocated buffer (not yet invented yet).

Usage: uf2bytes region font x y buffer
